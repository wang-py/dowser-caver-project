import numpy as np
import pandas as pd
import sys
import os
import subprocess

def csv_to_tunnel_points_arrays(tunnel_csv, tunnel_index):
    """
    a function that scans the tunnel profiles csv and chooses a certain 
    tunnel. This function should output an array of coordinates and sizes.
    ---------------------------------------------------------------------------
    tunnel_csv: str
    filename of the tunnel profile csv

    tunnel_index: int
    index of the chosen tunnel

    ----------------------------------------------------------------------------
    Returns:
    tunnel_points: ndarray
    3 x n numpy array of tunnel point coordinates

    """

    # skips information before coordinates
    skip_cols = 13
    # only takes coordinates of that tunnel
    tunnel_index_in_csv = (tunnel_index - 1) * 7 + 1
    rows_to_keep = [x for x in range(tunnel_index_in_csv, tunnel_index_in_csv + 3)]
    # scanning through the csv file
    tunnel_points = pd.read_csv(tunnel_csv, skiprows = lambda x: x not in rows_to_keep, \
        header=None)
    tunnel_points = tunnel_points.to_numpy()

    return tunnel_points[:, skip_cols:].astype(float)

def tunnel_points_to_box_configs(tunnel_points, output_folder):
    """
    a function that reads the output of the above function, then outputs
    a series of config files for AutoDock Vina. Default box size is 6, but it
    could be customized to each sphere's size.
    ----------------------------------------------------------------------------
    tunnel_points: 3 x n ndarray
    array of tunnel point coordinates

    output_folder: str
    folder to store the temporary box configs for Autodock Vina

    ----------------------------------------------------------------------------
    Returns:
    None
    """

    num_of_pts = tunnel_points.shape[1]
    receptor = "files/cavity_subunits.pdbqt"
    ligand = "files/water.pdbqt"
    energy_range = 100
    size = 6
    exhaustiveness = 32
    for i in range(num_of_pts):
        tp = tunnel_points[:,i]
        with open(output_folder + "/box_" + str(i) + ".txt", 'w') as file:
            file.write("receptor = " + str(receptor) + "\n")
            file.write("ligand = " + str(ligand) + "\n")
            file.write("\n")
            file.write("center_x = %.3f\n"%tp[0])
            file.write("center_y = %.3f\n"%tp[1])
            file.write("center_z = %.3f\n"%tp[2])
            file.write("\n")
            file.write("size_x = %.3f\n"%size)
            file.write("size_y = %.3f\n"%size)
            file.write("size_z = %.3f\n"%size)
            file.write("\n")
            file.write("energy_range = " + str(energy_range) + "\n")
            file.write("exhaustiveness = " + str(exhaustiveness) + "\n")
    pass

if __name__ == "__main__":
    # csv file generated by caver
    tunnel_csv = sys.argv[1]
    # the index of tunnel that we like to investigate
    tunnel_index = int(sys.argv[2])
    # output folder to store all output files
    output_folder = "boxes"
    try:
        os.mkdir(output_folder)
    except OSError as error:
        print("folder " + output_folder + " was already created.\n")
    # convert csv input into numpy arrays
    tp = csv_to_tunnel_points_arrays(tunnel_csv, tunnel_index)
    # generate input files for AutoDock Vina
    tunnel_points_to_box_configs(tp, output_folder)
    num_of_pts = tp.shape[1]
    final_output_name = output_folder + "/AllPredictions.pdbqt"
    # start docking water molecules along the caver tunnel
    for i in range(num_of_pts):
        prediction_filename = output_folder + "/point_%s.pdbqt"%str(i)
        prediction_temp = []
        vina_args = ("./vina", "--config", output_folder + "/box_%s.txt"%str(i), \
            "--out", prediction_filename)
        popen = subprocess.Popen(vina_args, stdout=subprocess.PIPE)
        popen.wait()
        output = popen.stdout.read()
        print(output.decode("utf-8"))
        # grepping the results
        with open(prediction_filename, 'r') as pf:
            for line in pf:
                if "ATOM" in line:
                    prediction_temp.append(line)

        # concatenate all predictions into one file
        with open(final_output_name, 'a+') as fo:
            fo.writelines(prediction_temp)

    pass
